function T(C){let{betAmount:o,percentageInterval:A,distributionType:M,currentProbability:N,minDistributionPercentage:d,maxDistributionPercentage:L,centerShift:k}=C,c=[],I=0,w=100;for(let t=I;t<=w;t++)c.push(`${t}%`);let p=Math.max(2,A),f=[],v=L-d;if(p===1)f.push(Math.round(d+v/2));else{let t=v/(p-1);for(let e=0;e<p;e++){let a=d+e*t;f.push(Math.round(a))}}let l=[...new Set(f)].sort((t,e)=>t-e),u=0,g=new Map;for(let t of l){let e=0,a=t,n=50;switch(M){case"linear":case"quadratic":case"exponential":case"exponential-inverse":case"exponential-negative":case"exponential-negative-inverse":case"square-root":case"linear-decay":case"quadratic-negative":case"square-root-negative":a=t-k;break;case"absolute":case"absolute-negative":case"logistic":case"negative-logistic":case"bell-curve":case"negative-bell-curve":n=50+k;break;case"constant":break}let r=.05,i=0;switch(M){case"linear":{e=a;break}case"linear-decay":{e=100-a;break}case"constant":{e=1;break}case"quadratic":{e=a*a;break}case"quadratic-negative":{e=(100-a)*(100-a);break}case"absolute":{e=Math.abs(t-n);break}case"absolute-negative":{e=50-Math.abs(t-n);break}case"logistic":{e=1/(1+Math.exp(-.15*(t-n)));break}case"negative-logistic":{e=1-1/(1+Math.exp(-.15*(t-n)));break}case"exponential":{i=a-1,e=Math.exp(i*r);break}case"exponential-inverse":{i=100-a-1,e=Math.exp(i*r);break}case"exponential-negative":{i=a-1,e=100-Math.exp(i*r);break}case"exponential-negative-inverse":{i=100-a-1,e=100-Math.exp(i*r);break}case"square-root":{e=Math.sqrt(Math.max(0,a));break}case"bell-curve":{e=100*Math.exp(-Math.pow(t-n,2)/(2*Math.pow(15,2)));break}case"negative-bell-curve":{e=100-100*Math.exp(-Math.pow(t-n,2)/(2*Math.pow(15,2)));break}case"square-root-negative":{e=Math.sqrt(Math.max(0,100-a));break}default:{e=t;break}}let D=Math.max(.01,e);g.set(t,D),u+=D}let x=0,s=[];if(u===0){let t=o>0?o/l.length:0;for(let e of l){let a=Math.round(t);s.push({percentage:e,amount:a}),x+=a}}else for(let t of l){let e=g.get(t)/u*o,a=Math.round(e);s.push({percentage:t,amount:a}),x+=a}let b=o-x;if(b!==0){let t=[];for(let e=0;e<s.length;e++){let a=u===0?o/l.length:g.get(s[e].percentage)/u*o,n=a-Math.floor(a);t.push({index:e,fraction:n})}b>0?t.sort((e,a)=>a.fraction-e.fraction):t.sort((e,a)=>e.fraction-a.fraction);for(let e=0;e<Math.abs(b);e++){let a=!1;for(let n=0;n<t.length;n++){let r=(e+n)%t.length,i=t[r].index;if(b>0){s[i].amount+=1,a=!0;break}else if(s[i].amount>0){s[i].amount-=1,a=!0;break}}if(!a)break}}for(let t of s)t.amount=Math.max(0,t.amount);let m=new Array(c.length).fill(null);for(let{percentage:t,amount:e}of s){let a=`${t}%`,n=c.indexOf(a);n!==-1&&(m[n]=e)}let P=m.length>0?Math.max(...m.filter(t=>t!==null).map(Number),0):0,S=P>0?Math.ceil(P*1.1/100)*100:100,y=Math.max(100,S),B=c.findIndex(t=>parseFloat(t)===N);return{allXAxisLabels:c,mainDatasetData:m,finalPaddedMaxY:y,barIndex:B,calculatedPoints:s.filter(t=>t.amount>0)}}export{T as a};
